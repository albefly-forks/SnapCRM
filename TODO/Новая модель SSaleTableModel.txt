Концепция новой модели данных таблицы работ и деталей (используемой при продаже товаров и в карточке ремонта).

Текущая модель
Наследует QStandardItemModel. Данные загружаются в прокси-модель, а затем копируются.
 - Запросы, используемые при загрузке списка и при добавлении работы/детали, а также enum, представляющий порядок столбцов, связаны и при расширении функционала требуется изменять сразу всё;
     ASSERT, используемый для проверки ошибки программиста, конечно, чуть-чуть упрощает задачу, но желательно сделать более понятную реализацию;
 - При изменении данных (например, в карточке ремонта) поле помечается и в БД записываются только изменённые данные;
 - при сохранении производится обход всех полей таблицы в цикле и в зависимости от типа записи (работа/товар) формируется запрос для соответствующей таблицы.

Новая модель
Может наследовать STableBaseModel.
 - данные загружаются в две прокси-модели (каждая для своей таблицы); поидее, подойдут модели QSqlTableModel;
 - две прокси-модели позволят отказаться от специфических служебных столбцов, например, SStoreItemModel::SaleOpColumns::ColRecordType;
 - кол-во строк, возвращаемое при вызове метода rowsCount(), соответствует сумме строк прокси-моделей;
 - для уменьшения задержек предусмотреть массив(-ы) rowsOffsets, после загрузки или добавления/удаления новых строк производить пересчет смещений;
 - кол-во столбцов, возвращаемое при вызове метода columnsCount(), жестко задано; 
 - для уменьшения задержек предусмотреть массив(-ы) columnsOffsets, после загрузки или добавления/удаления новых строк производить пересчет смещений;
 - при вызове метода data(...) будет отдаваться объект QVariant из соответствующей прокси-модели;
 - нулевой строкой пытаемся вывести работу из первой прокси-модели, а следующей — товары из второй с соответствующей связью;
