Концепция механизма обработки сбоя соединения с сервером

Сбой может быть определён, если метод QSqlQuery::exec вернёт нуль;
  - при этом с помощью методов QSqlError::text() или QSqlError::driverText() узнать точную причину не удастся, т. к. плагин возвращает всегда один и тот же текст;
  - точную ошибку можно узнать с помощью метода QSqlError::nativeErrorCode() и обрабатывать её (например, сбой соединения это ошибка 2003);
  - чтобы зависание интерфейса было как можно недолгим, нужно задать таймаут с помощью параметра драйвера "MYSQL_OPT_CONNECT_TIMEOUT=x", где x время в секундах;
  - пытаться модифицировать плагин Qt не имеет смысла, т. к. всё равно всё упирается в библиотеку mysql и время таймаута;

Два глобальных таймера:
  №1 — выполнение запросов при восстановлении соединения
  №2 — проверка восстановления связи

Таймер №1 работает постоянно, пока не определён сбой; интервал небольшой, например 5мс
Когда определён сбой:
   - таймер №1 останавливается;
   - таймер №2 запускается;
   - создаётся объект QWidget являющийся индиктатором сбоя; отображается на видном месте, но не перекрывает элементы интерфейса;
   - создаётся объект модального уведомления (пользователь может его закрыть);
В классы необходимо добавть вспомогательные методы, которые будут проверять работает таймер №1 или остановлен;
  если таймер №1 работает, то метод, непосредственно выполняющий запросы к БД, будет вызываться немедленно;
  если таймер №1 остановлен, то к сигналу timeout() будет подключена лямбда-функция;
    когда соединение с БД восстановится и таймер №1 вновь заработает, произойдёт вызов метода непосредственно выполняющего запросы к БД;
    соединение сигнал/лямбда после этого должно быть разорвано (в Qt5 это придётся делать вручную, примеры и ссылки см. в конце; в Qt6 такой механизм реализован штатно);
    дополнительно нужно обдумать как не создавать соединение сигнал/лямбда, если оно уже есть;

Таймер №2 начинает работу, когда обнаружен сбой соединения и с определённым интервалом проверяет не восстановилось ли оно (например с пом. запроса "SELECT NOW();")
запрос для проверки соединения, вероятно, нужно выполнять асинхронно, чтобы интерфейс не зависал при ожидании ответа;
если обнаружено, что соединение восстановлено:
   - таймер №2 останавливается;
   - таймер №1 запускается;
   - индикатор сбоя связи (QWidget) удаляется;
   - если модальное уведомление не было закрыто пользователем, то оно также удаляется;


===================================================================================================================================
Пример единоразово вызываемого слота (найден на станице https://bugreports.qt.io/browse/QTBUG-44219?focusedCommentId=447865):
  auto con = QSharedPointer<QMetaObject::Connection>::create();
   *con = QObject::connect(foo, &Foo::bar, [con] {
       QObject::disconnect(*con);
       //...
   });

Еще примеры:
  https://stackoverflow.com/questions/55000571/qt5-one-shot-connection-to-lambda
  https://forum.qt.io/topic/67272/how-to-create-a-single-shot-one-time-connection-to-a-lambda/7