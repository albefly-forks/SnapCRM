Вкладка Продажа (она же — просмотр расходной накладной)
QSqlTableModel не подходит потому что:
  - setQuery() является protected и чтобы вывести результаты нескольких таблиц, придётся использовать QSqlRelationalTableModel;
  - можно унаследовать этот класс в котором реализовать метод setQuery() и спокойно запрашивать только те столбцы, что меня интересуют. НО! при изменении данных и записи в БД метод submitAll() возвращает
    false; запись в БД происходит успешно, а вот последующий select завершается с ошибкой, т. к. для него собирается новый запрос, содержащий имена столбцов присоединяемой таблицы (если запрос с присоединяемой таблицей).
    Соответственно, могут быть ошибки в отображаемых данных в tableView, т. к. модель не обновится.
  - штатными методами нельзя запросить только интересующие стоблцы, придётся скрывать столбцы tableView;
  - все поля являются редактируемыми; т. е. всё равно нужно реализовать свой класс для изменения флагов индексов;
  - запись в таблицу выполняется не сессионно (BEGIN, COMMIT; хотя, может это и плюс);
  - проверку правильности записи данных всё равно придётся делать отдельно.
  - метод insertRows() не хитрый, думаю, можно без проблем реализовать свой.

QSqlTableModel (QSqlRelationalTableModel) удобен тем что:
  - не придётся заботится о запросах для записи данных в таблицу БД (в т. ч. при присоединённых таблицах);
  - реализованы методы insertRows() (в базовых классах нет), insertRecord(), setRecord() и др.;

QSqlRelationalTableModel не подходит (или не имеет смысла) потому что:
  - после запроса с JOIN, производится запрос ВСЕХ строк присоединяемой(-ых) таблиц(ы), а это может здорово расходовать память да и просто медленно, если данных много.
  - аналогично базовому классу, нельзя запросить только интересующие стоблцы;
  - аналогично базовому классу, все поля редактируемые.
  - аналогично базовому классу, запись в таблицу выполняется не сессионно;
  - 

QSqlQueryModel плох тем что:
  - метод  insertRows, наследуемый от базового класса QAbstractItemModel, не содержит реализации;

QSqlQueryModel (точнее свой класс, наследующий public методы), подходит лучше потому что:
  - есть метод setQuery, при вызове которого обновляются данные в виджете
  - 










При добавлении товара делаем запрос SELECT из таблицы store_items по id; названия столбцов нужно задавать таким образом, чтобы они соответствовали названиям в табл. store_sales.
Затем в модели таблицы продажи добавляем новую строку и заполняем её данными из record (тут дилемма):
1) если базовый класс QSqlQueryModel: 
  - нужно реализовать метод копирования по имени столбца (чтобы уменьшить кол-во возможных глюков при изменении запросов)
  - нужно реализовать метод записи данных в БД при редактировании (в АЦС не было редактирования и частичного распроведения РН, а у меня будет);
2) если базовый класс QSqlTableModel: нужно реализовать свой метод 
  - нужно как-то заменить record в private классе (т. к. изначальный запрос будет с присоединяемыми таблицами) и убрать оттуда поля присоединяемых таблиц.