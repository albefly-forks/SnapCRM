В АСЦ во всех версиях была проблема с блокировкой карты ремонта. Попробую сделать по своему.
Блокировка будет, но будет и механизм запрос-ответ для автоматической разблокировки. Также этот мех-м можно будет использовать и для других целей.
Таблица запросов ответов:
id
type        0 - request/ 1 - answer
created     UTC_TIMESTAMP()
request_id  NULL для type=0/id для type=1
message_type  0 - запрос на разблокировку карты ремонта
request_obj_id  id интересующего ресурса: для message_type=0 это номер ремонта
sender_user  id пользователя запрашивающей/отвечающей стороны
receiver_user  id пользователя запрашиваемой/принимающей стороны

Как это работает:
При открытии карты ремонта, производится запись о её блокировке; пока карта открыта специальный диспетчер по таймеру проверяет наличие запросов на разблокировку карты другим клиентом (для этого в классе tabRepair есть статичная переменная-массив QMap).
При открытии заблокированнйо карты вторым клиентом происходит создание запроса на разблокировку в специальной таблице и запускается таймер ожидания подтвержения блокировки первым клиентом. Во время работы этого таймера производится периодическая проверка появления ответа на запрос и по истечении таймера, если ответа не было, второй клиент заменяет блокировку. Если же ответ был, то запускается второй таймер, но с большим интервалом, по истечении которого производится проверка блокировки карты ремонта и повторная отправка запроса на разблокировку.
БУДЕТ ДОПОЛНЕНО...

Изучить что за зверь bool QSqlDriver::subscribeToNotification(const QString &name)